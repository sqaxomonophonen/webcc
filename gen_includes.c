// THIS FILE WAS AUTO-GENEREATED; DO NOT EDIT
// instead: edit include/*, then run ./nob gen_includes.c
const int num_gen_includes = 7;
const char* gen_includes[][2] = {
{
"float.h",
"#ifndef __STDFLOAT_H\n"
"#define __STDFLOAT_H\n"
"#define DECIMAL_DIG 21\n"
"#define FLT_EVAL_METHOD 0 // C11 5.2.4.2.2p9\n"
"#define FLT_RADIX 2\n"
"#define FLT_ROUNDS 1      // C11 5.2.4.2.2p8: to nearest\n"
"#define FLT_DIG 6\n"
"#define FLT_EPSILON 0x1p-23\n"
"#define FLT_MANT_DIG 24\n"
"#define FLT_MAX 0x1.fffffep+127\n"
"#define FLT_MAX_10_EXP 38\n"
"#define FLT_MAX_EXP 128\n"
"#define FLT_MIN 0x1p-126\n"
"#define FLT_MIN_10_EXP -37\n"
"#define FLT_MIN_EXP -125\n"
"#define FLT_TRUE_MIN 0x1p-149\n"
"#define DBL_DIG 15\n"
"#define DBL_EPSILON 0x1p-52\n"
"#define DBL_MANT_DIG 53\n"
"#define DBL_MAX 0x1.fffffffffffffp+1023\n"
"#define DBL_MAX_10_EXP 308\n"
"#define DBL_MAX_EXP 1024\n"
"#define DBL_MIN 0x1p-1022\n"
"#define DBL_MIN_10_EXP -307\n"
"#define DBL_MIN_EXP -1021\n"
"#define DBL_TRUE_MIN 0x0.0000000000001p-1022\n"
"#define LDBL_DIG 15\n"
"#define LDBL_EPSILON 0x1p-52\n"
"#define LDBL_MANT_DIG 53\n"
"#define LDBL_MAX 0x1.fffffffffffffp+1023\n"
"#define LDBL_MAX_10_EXP 308\n"
"#define LDBL_MAX_EXP 1024\n"
"#define LDBL_MIN 0x1p-1022\n"
"#define LDBL_MIN_10_EXP -307\n"
"#define LDBL_MIN_EXP -1021\n"
"#define LDBL_TRUE_MIN 0x0.0000000000001p-1022\n"
"#endif\n"
},
{
"stdalign.h",
"#ifndef __STDALIGN_H\n"
"#define __STDALIGN_H\n"
"#define alignas _Alignas\n"
"#define alignof _Alignof\n"
"#define __alignas_is_defined 1\n"
"#define __alignof_is_defined 1\n"
"#endif\n"
},
{
"stdarg.h",
"#ifndef __STDARG_H\n"
"#define __STDARG_H\n"
"typedef struct {\n"
"  unsigned int gp_offset;\n"
"  unsigned int fp_offset;\n"
"  void *overflow_arg_area;\n"
"  void *reg_save_area;\n"
"} __va_elem;\n"
"typedef __va_elem va_list[1];\n"
"#define va_start(ap, last)   do { *(ap) = *(__va_elem *)__va_area__; } while (0)\n"
"#define va_end(ap)\n"
"static void *__va_arg_mem(__va_elem *ap, int sz, int align) {\n"
"  void *p = ap->overflow_arg_area;\n"
"  if (align > 8)\n"
"    p = (p + 15) / 16 * 16;\n"
"  ap->overflow_arg_area = ((unsigned long)p + sz + 7) / 8 * 8;\n"
"  return p;\n"
"}\n"
"static void *__va_arg_gp(__va_elem *ap, int sz, int align) {\n"
"  if (ap->gp_offset >= 48)\n"
"    return __va_arg_mem(ap, sz, align);\n"
"  void *r = ap->reg_save_area + ap->gp_offset;\n"
"  ap->gp_offset += 8;\n"
"  return r;\n"
"}\n"
"static void *__va_arg_fp(__va_elem *ap, int sz, int align) {\n"
"  if (ap->fp_offset >= 112)\n"
"    return __va_arg_mem(ap, sz, align);\n"
"  void *r = ap->reg_save_area + ap->fp_offset;\n"
"  ap->fp_offset += 8;\n"
"  return r;\n"
"}\n"
"#define va_arg(ap, ty)                                                    ({                                                                        int klass = __builtin_reg_class(ty);                                    *(ty *)(klass == 0 ? __va_arg_gp(ap, sizeof(ty), _Alignof(ty)) :                klass == 1 ? __va_arg_fp(ap, sizeof(ty), _Alignof(ty)) :                __va_arg_mem(ap, sizeof(ty), _Alignof(ty)));                  })\n"
"#define va_copy(dest, src) ((dest)[0] = (src)[0])\n"
"#define __GNUC_VA_LIST 1\n"
"typedef va_list __gnuc_va_list;\n"
"#endif\n"
},
{
"stdatomic.h",
"#ifndef __STDATOMIC_H\n"
"#define __STDATOMIC_H\n"
"#define ATOMIC_BOOL_LOCK_FREE 1\n"
"#define ATOMIC_CHAR_LOCK_FREE 1\n"
"#define ATOMIC_CHAR16_T_LOCK_FREE 1\n"
"#define ATOMIC_CHAR32_T_LOCK_FREE 1\n"
"#define ATOMIC_WCHAR_T_LOCK_FREE 1\n"
"#define ATOMIC_SHORT_LOCK_FREE 1\n"
"#define ATOMIC_INT_LOCK_FREE 1\n"
"#define ATOMIC_LONG_LOCK_FREE 1\n"
"#define ATOMIC_LLONG_LOCK_FREE 1\n"
"#define ATOMIC_POINTER_LOCK_FREE 1\n"
"typedef enum {\n"
"  memory_order_relaxed,\n"
"  memory_order_consume,\n"
"  memory_order_acquire,\n"
"  memory_order_release,\n"
"  memory_order_acq_rel,\n"
"  memory_order_seq_cst,\n"
"} memory_order;\n"
"#define ATOMIC_FLAG_INIT(x) (x)\n"
"#define atomic_init(addr, val) (*(addr) = (val))\n"
"#define kill_dependency(x) (x)\n"
"#define atomic_thread_fence(order)\n"
"#define atomic_signal_fence(order)\n"
"#define atomic_is_lock_free(x) 1\n"
"#define atomic_load(addr) (*(addr))\n"
"#define atomic_store(addr, val) (*(addr) = (val))\n"
"#define atomic_load_explicit(addr, order) (*(addr))\n"
"#define atomic_store_explicit(addr, val, order) (*(addr) = (val))\n"
"#define atomic_fetch_add(obj, val) (*(obj) += (val))\n"
"#define atomic_fetch_sub(obj, val) (*(obj) -= (val))\n"
"#define atomic_fetch_or(obj, val) (*(obj) |= (val))\n"
"#define atomic_fetch_xor(obj, val) (*(obj) ^= (val))\n"
"#define atomic_fetch_and(obj, val) (*(obj) &= (val))\n"
"#define atomic_fetch_add_explicit(obj, val, order) (*(obj) += (val))\n"
"#define atomic_fetch_sub_explicit(obj, val, order) (*(obj) -= (val))\n"
"#define atomic_fetch_or_explicit(obj, val, order) (*(obj) |= (val))\n"
"#define atomic_fetch_xor_explicit(obj, val, order) (*(obj) ^= (val))\n"
"#define atomic_fetch_and_explicit(obj, val, order) (*(obj) &= (val))\n"
"#define atomic_compare_exchange_weak(p, old, new)   __builtin_compare_and_swap((p), (old), (new))\n"
"#define atomic_compare_exchange_strong(p, old, new)   __builtin_compare_and_swap((p), (old), (new))\n"
"#define atomic_exchange(obj, val) __builtin_atomic_exchange((obj), (val))\n"
"#define atomic_exchange_explicit(obj, val, order) __builtin_atomic_exchange((obj), (val))\n"
"#define atomic_flag_test_and_set(obj) atomic_exchange((obj), 1)\n"
"#define atomic_flag_test_and_set_explicit(obj, order) atomic_exchange((obj), 1)\n"
"#define atomic_flag_clear(obj) (*(obj) = 0)\n"
"#define atomic_flag_clear_explicit(obj, order) (*(obj) = 0)\n"
"typedef _Atomic _Bool atomic_flag;\n"
"typedef _Atomic _Bool atomic_bool;\n"
"typedef _Atomic char atomic_char;\n"
"typedef _Atomic signed char atomic_schar;\n"
"typedef _Atomic unsigned char atomic_uchar;\n"
"typedef _Atomic short atomic_short;\n"
"typedef _Atomic unsigned short atomic_ushort;\n"
"typedef _Atomic int atomic_int;\n"
"typedef _Atomic unsigned int atomic_uint;\n"
"typedef _Atomic long atomic_long;\n"
"typedef _Atomic unsigned long atomic_ulong;\n"
"typedef _Atomic long long atomic_llong;\n"
"typedef _Atomic unsigned long long atomic_ullong;\n"
"typedef _Atomic unsigned short atomic_char16_t;\n"
"typedef _Atomic unsigned atomic_char32_t;\n"
"typedef _Atomic unsigned atomic_wchar_t;\n"
"typedef _Atomic signed char atomic_int_least8_t;\n"
"typedef _Atomic unsigned char atomic_uint_least8_t;\n"
"typedef _Atomic short atomic_int_least16_t;\n"
"typedef _Atomic unsigned short atomic_uint_least16_t;\n"
"typedef _Atomic int atomic_int_least32_t;\n"
"typedef _Atomic unsigned int atomic_uint_least32_t;\n"
"typedef _Atomic long atomic_int_least64_t;\n"
"typedef _Atomic unsigned long atomic_uint_least64_t;\n"
"typedef _Atomic signed char atomic_int_fast8_t;\n"
"typedef _Atomic unsigned char atomic_uint_fast8_t;\n"
"typedef _Atomic short atomic_int_fast16_t;\n"
"typedef _Atomic unsigned short atomic_uint_fast16_t;\n"
"typedef _Atomic int atomic_int_fast32_t;\n"
"typedef _Atomic unsigned int atomic_uint_fast32_t;\n"
"typedef _Atomic long atomic_int_fast64_t;\n"
"typedef _Atomic unsigned long atomic_uint_fast64_t;\n"
"typedef _Atomic long atomic_intptr_t;\n"
"typedef _Atomic unsigned long atomic_uintptr_t;\n"
"typedef _Atomic unsigned long atomic_size_t;\n"
"typedef _Atomic long atomic_ptrdiff_t;\n"
"typedef _Atomic long atomic_intmax_t;\n"
"typedef _Atomic unsigned long atomic_uintmax_t;\n"
"#endif\n"
},
{
"stdbool.h",
"#ifndef __STDBOOL_H\n"
"#define __STDBOOL_H\n"
"#define bool _Bool\n"
"#define true 1\n"
"#define false 0\n"
"#define __bool_true_false_are_defined 1\n"
"#endif\n"
},
{
"stddef.h",
"#ifndef __STDDEF_H\n"
"#define __STDDEF_H\n"
"#define NULL ((void *)0)\n"
"typedef unsigned long size_t;\n"
"typedef long ptrdiff_t;\n"
"typedef unsigned int wchar_t;\n"
"typedef long max_align_t;\n"
"#define offsetof(type, member) ((size_t)&(((type *)0)->member))\n"
"#endif\n"
"L_DIG 21\n"
},
{
"stdnoreturn.h",
"#ifndef __STDNORETURN_H\n"
"#define __STDNORETURN_H\n"
"#define noreturn _Noreturn\n"
"#endif\n"
},
};
